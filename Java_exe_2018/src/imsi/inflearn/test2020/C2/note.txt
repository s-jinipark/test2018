시간 복잡도
 문제를 효율적으로 해결
  - 똑같은 문제를 해결해도 빠르게 해결하는 것이 중요
  - 같은 입력을 제공했을 때, 어느 프로그램이 더 빠른가?
  - 내 프로그램은 얼마나 빠를까? (예측하고 싶다)
  
  - 프로그램이 대략적으로 몇 개의 명령을 수행하는가?
    대충 6개 수행 , O(6) , order 6  
	=> O(1) 로 표현 , 상수 번 수행
	
	for 로 0 부터 n-1 까지 합계 구할 경우
	반복문 있는 경우 , n 번 수행
	대충 5개 수행 for n 번 수행 , O(n+5) 
	=> O(n) 으로 표현
	
	중첩 for 도 있고 for 도 있다
	O(n2 + n)
	=> O(n2) 으로 표현 , (n2 는 제곱을 표현한 것임)

	중첩 for 인데 두번째 j=i 
	i 값에 따라 j 의 범위가 달라짐
	n, n-1, n-2, n-3, ... 1
	n(n+1) / 2
	=> O(n2) 으로 표현 , (n2 는 제곱을 표현한 것임)

	for 문 안에 if ... break
	n 의 값에 따라 빨리 break 되던가 끝까지 가던가
	항상 최악일 때를 가정함
	=> O(n)
	반복문이 시간 복잡도를 결정

명령 수행 수 vs 실제 시간
 - 명령을 많이 실행하면 시간도 오래 걸릴 것이다
 
 - 구체적으로 얼마나 걸리는가?
 

Adv. Brute-Force Algorithm

 - 모든 경우를 시도해봄으로써 답을 구하는 방법
	N 개의 숫자중에서 최솟값을 구하여라
	
 - 코드를 짜기가 까다로운 경우
	N 개의 카드가 있고 각각은 1부터 N 까지 번호를 갖는다
	이를 한 줄로 세울 수 있는 모든 경우를 출력하시오
	=> N 개의 카드가 3개 있으면 -> 삼중 for 문
                 4개 면 -> 4중
 - N 중 for 문을 돌려야 한다?
   => 재귀 호출
   
 - 아이디어

	
   
	